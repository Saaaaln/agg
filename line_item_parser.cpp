// Read lineitem table as generated by TPC-H

#include <iostream>
#include <fstream>
#include <algorithm>
#include <sys/time.h>
#include <string.h>
#include "line_item_parser.h"
#include<cstring>


const tm ParseDate(const std::string &date_string) {
    time_t raw_time;
    time(&raw_time);
    struct tm date;
    localtime_r(&raw_time, &date);
    date.tm_year = atoi(date_string.substr(0, 4).c_str());
    date.tm_mon = atoi(date_string.substr(5, 2).c_str()) - 1;
    date.tm_mday = atoi(date_string.substr(8, 2).c_str());

    return date;
}

void ReadUntilSeparator(std::ifstream &in_file, char *out, const int len) {
    std::string buf;
    std::getline(in_file, buf, '|');

    strcpy(out, buf.c_str());

//	strcpy_s(out, len, buf.c_str());
}

const tm ReadDate(std::ifstream &in_file) {
    std::string buf;
    std::getline(in_file, buf, '|');

    return ParseDate(buf);
}


std::vector<LineItem> &ReadAndParseLineItems(const std::string &file_path) {
    std::vector<LineItem> &items = *new std::vector<LineItem>;

    std::ifstream in_file(file_path);

    if (!in_file.good()) {
        std::cerr << "File '" << file_path << "' does not exist\n";
    }

    int counter = 0;

    LineItem current;
    char delimiter;
    while (in_file >> current.order_key >> delimiter
                   >> current.part_key >> delimiter
                   >> current.supp_key >> delimiter
                   >> current.line_number >> delimiter
                   >> current.quantity >> delimiter
                   >> current.extended_price >> delimiter
                   >> current.discount >> delimiter
                   >> current.tax >> delimiter
                   >> current.return_flag >> delimiter
                   >> current.line_status >> delimiter
            ) {
        current.ship_date = ReadDate(in_file);
        current.commit_date = ReadDate(in_file);
        current.receipt_date = ReadDate(in_file);

        ReadUntilSeparator(in_file, current.ship_instruct,
                           sizeof(current.ship_instruct) / sizeof(current.ship_instruct[0]));
        ReadUntilSeparator(in_file, current.ship_mode, sizeof(current.ship_mode) / sizeof(current.ship_mode[0]));
        ReadUntilSeparator(in_file, current.comment, sizeof(current.comment) / sizeof(current.comment[0]));
        items.push_back(current);
        counter++;
    }
    // Include some spaces to overwrite big numbers that might be printed above
//	std::cout << "Done reading line items     \n";
//	std::random_shuffle(items.begin(), items.end(), random);
    return items;
}

void ReadAndProjAllLineItems(const std::string &file_path) {
    std::vector<LineItem> &items = *new std::vector<LineItem>;

    std::ifstream in_file(file_path);

    if (!in_file.good()) {
        std::cerr << "File '" << file_path << "' does not exist\n";
    }

    int counter = 0;
    int write_count = 0;

    LineItem current;
    char delimiter;

    struct timeval t1, t2;
    int deltaT = 0;

    gettimeofday(&t1, NULL);

    std::ofstream dataFile;
    dataFile.open("/home/he/Desktop/proj_lineitem_sf100.tbl", std::ofstream::app);

    while (in_file >> current.order_key >> delimiter
                   >> current.part_key >> delimiter
                   >> current.supp_key >> delimiter
                   >> current.line_number >> delimiter
                   >> current.quantity >> delimiter
                   >> current.extended_price >> delimiter
                   >> current.discount >> delimiter
                   >> current.tax >> delimiter
                   >> current.return_flag >> delimiter
                   >> current.line_status >> delimiter
            ) {
        current.ship_date = ReadDate(in_file);
        current.commit_date = ReadDate(in_file);
        current.receipt_date = ReadDate(in_file);

        ReadUntilSeparator(in_file, current.ship_instruct,
                           sizeof(current.ship_instruct) / sizeof(current.ship_instruct[0]));
        ReadUntilSeparator(in_file, current.ship_mode, sizeof(current.ship_mode) / sizeof(current.ship_mode[0]));
        ReadUntilSeparator(in_file, current.comment, sizeof(current.comment) / sizeof(current.comment[0]));
        items.push_back(current);

        ++counter;

        dataFile << current << std::endl;

        ++write_count;

        if (counter % 6001215 == 0) {
            gettimeofday(&t2, NULL);
            deltaT  = (t2.tv_sec - t1.tv_sec) * 1000000 + t2.tv_usec - t1.tv_usec;
            printf("--------load&write 6001215 tuples is over costs time (ms) = %lf\n", deltaT * 1.0 / 1000);
            std::cout << "size:" << items.size() << std::endl;
            dataFile.flush();
            items.clear();
            std::cout << "items.capacity:" << items.capacity() << std::endl;
            //capacity:8388608
            std::vector<LineItem>().swap(items);
            std::cout << "after swap, items.capacity:" << items.capacity() << std::endl;
            gettimeofday(&t1, NULL);
            std::cout << "read tuple numbers:" << counter << std::endl;
            std::cout << "write tuple numbers:" << write_count << std::endl;
            gettimeofday(&t1, NULL);
        }
    }
    std::cout << "total read tuple numbers:" << counter << std::endl;
    std::cout << "total write tuple numbers:" << write_count << std::endl;
    dataFile.close();
}


std::vector<ProjLineItem> &ReadAndParseProjLineItems(const std::string &file_path) {
    std::vector<ProjLineItem> &items = *new std::vector<ProjLineItem>;

    std::ifstream in_file(file_path);

    if (!in_file.good()) {
        std::cerr << "File '" << file_path << "' does not exist\n";
    }


    ProjLineItem current;
    char delimiter;
    while (in_file >> current.order_key >> delimiter
                   >> current.quantity >> delimiter
            ) {
        items.push_back(current);
    }
    // Include some spaces to overwrite big numbers that might be printed above
//	std::cout << "Done reading line items     \n";
//	std::random_shuffle(items.begin(), items.end(), random);
    return items;
}
